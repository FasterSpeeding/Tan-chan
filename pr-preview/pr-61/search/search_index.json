{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tan-chan","text":"<p>A utility library which extends Tanjun.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install Tan-chan from PyPI using the following command in any Python 3.9 or above environment.</p> <pre><code>python -m pip install -U tanchan\n</code></pre>"},{"location":"#quick-usage","title":"Quick Usage","text":"<p>For usage see the documentation and the usage guide.</p>"},{"location":"#support","title":"Support","text":"<p>Hikari's support guild provides for support for Tan-chan.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Before contributing you should read through the contributing guidelines and the code of conduct.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#030-2023-03-12","title":"0.3.0 - 2023-03-12","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>with_annotated_args will now also parse   option descriptions form the docstring of the typed dict being used as an   unpacked <code>**kwargs</code> type hint.</li> </ul>"},{"location":"changelog/#022post-2023-03-04","title":"0.2.2.post - 2023-03-04","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>SlashCommandGroup.as_sub_command   now actually adds the created command to the group.</li> </ul>"},{"location":"changelog/#022-2023-03-03","title":"0.2.2 - 2023-03-03","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Extended tanjun.SlashCommandGroup impl at tanchan.doc_parse.SlashCommandGroup   where the <code>name</code>, and <code>description</code> parameters are now optional and introspected from   the callback's docstring by default for   SlashCommandGroup.as_sub_command.   SlashCommandGroup.make_sub_group   also returns a tanchan.doc_parse.SlashCommandGroup instance.</li> <li>Optional <code>description</code> arg to tanchan.doc_parse.as_slash_command to allow   overriding the introspected value.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>tanchan.doc_parse.as_slash_command is now typed to allow decorating   commands which match the abstract types in tanjun.abc, not just the   standard impls.</li> <li>A mapping of locales to values can now be passed for <code>name</code> to   tanchan.doc_parse.as_slash_command.</li> </ul>"},{"location":"changelog/#021-2023-02-01","title":"0.2.1 - 2023-02-01","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Bumped the minimum Tanjun version to <code>v2.11.3</code>.</li> <li>Updated the type-hints for tanchan.doc_parse.as_slash_command to match   changes to Tanjun.</li> </ul>"},{"location":"changelog/#020-2022-12-07","title":"0.2.0 - 2022-12-07","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Support for Sphinx style reST docs to doc parse.</li> <li>Optional <code>name</code> argument to tanchan.doc_parse.as_slash_command which   allows overriding the command's name.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>tanchan.doc_parse.as_slash_command no-longer errors when the callback's   docstring is just the description and <code>doc_style</code> is None.</li> <li>tanchan.doc_parse.with_annotated_args now allows None to be explicitly   passed to <code>doc_style</code> typing wise.</li> </ul>"},{"location":"changelog/#010-2022-12-02","title":"0.1.0 - 2022-12-02","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>An extension to tanjun.annotations which allows for parsing slash command   descriptions (including for options) from the command callback's docstring +   using the callback's name as the command's name.</li> </ul>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#doc-parse","title":"Doc parse","text":"<p>tanchan.doc_parse exposes two methods which help with declaring slash commands:</p> <pre><code>import tanjun\nfrom tanchan import doc_parse\n\n# This command will show up as \"meow\" in the command menu\n@doc_parse.as_slash_command()\nasync def meow(ctx: tanjun.abc.SlashContext) -&gt; None:\n\"\"\"Meow command's description.\"\"\"\n    ...\n\nget_group = tanjun.slash_command_group(\"get\", \"Get command group\")\n\n# This command will show up as \"get user\" in the command menu\n@get_group.with_command\n@doc_parse.as_slash_command()\nasync def user(ctx: tanjun.abc.SlashContext) -&gt; None:\n\"\"\"Get a user.\"\"\"\n    ...\n</code></pre> <p>tanchan.doc_parse.as_slash_command acts as an extension to tanjun.as_slash_command which uses the function's name as the command's name and the first line of its docstring as the command's description.</p> <pre><code>import typing\n\nimport tanjun\nfrom tanchan import doc_parse\nfrom tanjun import annotations\n\n# Google's doc style.\n@doc_parse.with_annotated_args\n@doc_parse.as_slash_command()\nasync def ban(\n    ctx: tanjun.abc.SlashContext,\n    user: annotations.User,\n    reason: typing.Optional[annotations.Length[460]] = None,\n) -&gt; None:\n\"\"\"Ban a user from this guild.\n\n    Args:\n        user: The user to ban from this guild.\n        reason: The reason for the ban.\n            If not provided then a generic reason will be used.\n    \"\"\"\n\n# NumPy's doc style.\n@doc_parse.with_annotated_args\n@doc_parse.as_slash_command()\nasync def kick(\n    ctx: tanjun.abc.SlashContext,\n    member: annotations.Member,\n    reason: typing.Optional[annotations.Length[460]] = None,\n) -&gt; None:\n\"\"\"Kick a member from this guild.\n\n    Parameters\n    ----------\n    member\n        The guild member to kick.\n    reason\n        The reason for the kick.\n        If not provided then a generic reason will be used.\n    \"\"\"\n\n# Sphinx's \"reST\" doc style.\n@doc_parse.with_annotated_args\n@doc_parse.as_slash_command()\nasync def echo(\n    ctx: tanjun.abc.SlashContext,\n    content: annotations.Str,\n    channel: typing.Optional[annotations.Channel] = None,\n) -&gt; None:\n\"\"\"Make the bot echo a message.\n\n    :param content: The message to echo.\n    :param channel: The channel to echo to.\n        If not provided then the current channel will be targeted.\n    \"\"\"\n</code></pre> <p>tanchan.doc_parse.with_annotated_args uses the functionality exposed in tanjun.annotations but with the added feature that slash command option descriptions are parsed from the docstring. This supports Google's doc style, NumPy's doc style, and Sphinx's \"reST\" doc style.</p>"},{"location":"reference/doc_parse/","title":"tanchan.doc_parse","text":"<p>tanjun.annotations extension which uses docstring parsing.</p>"},{"location":"reference/doc_parse/#tanchan.doc_parse.SlashCommandGroup","title":"SlashCommandGroup","text":"<p>         Bases: <code>tanjun.SlashCommandGroup</code></p> <p>Extended implementation of tanjun.SlashCommandGroup with some doc parsing.</p>"},{"location":"reference/doc_parse/#tanchan.doc_parse.SlashCommandGroup.as_sub_command","title":"as_sub_command","text":"<pre><code>as_sub_command(name=None, description=None, *, always_defer=False, default_to_ephemeral=None, sort_options=True, validate_arg_keys=True)\n</code></pre> <p>Build a tanjun.SlashCommand in this command group by decorating a function.</p> <p>Note</p> <p>If you want your first response to be ephemeral while using <code>always_defer</code>, you must set <code>default_to_ephemeral</code> to <code>True</code>.</p> PARAMETER DESCRIPTION <code>name</code> <p>The command's name (supports localisation).</p> <p>If left as None then the command callback's name will be used.</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>The command's description.</p> <p>If left as None then the first line of the command callback's description will be used.</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>None</code> </p> <code>always_defer</code> <p>Whether the contexts this command is executed with should always be deferred before being passed to the command's callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>sort_options</code> <p>Whether this command should sort its set options based on whether they're required.</p> <p>If this is True then the options are re-sorted to meet the requirement from Discord that required command options be listed before optional ones.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.SlashCallbackSig], SlashCommand]</code> <p>The decorator callback used to make a sub-command.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand tanjun.SlashCommand).</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name doesn't fit Discord's requirements.</li> <li>If the command name has uppercase characters.</li> <li>If the description is over 100 characters long.</li> </ul>"},{"location":"reference/doc_parse/#tanchan.doc_parse.SlashCommandGroup.make_sub_group","title":"make_sub_group","text":"<pre><code>make_sub_group(name, description, /, *, default_to_ephemeral=None)\n</code></pre> <p>Create a sub-command group in this group.</p> <p>Note</p> <p>Unlike message command groups, slash command groups cannot be callable functions themselves.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the command group (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The description of the command group.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>SlashCommandGroup</code> <p>The created sub-command group.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name doesn't fit Discord's requirements.</li> <li>If the command name has uppercase characters.</li> <li>If the description is over 100 characters long.</li> </ul>"},{"location":"reference/doc_parse/#tanchan.doc_parse.as_slash_command","title":"as_slash_command","text":"<pre><code>as_slash_command(*, always_defer=False, default_member_permissions=None, default_to_ephemeral=None, description=None, dm_enabled=None, is_global=True, name=None, sort_options=True, validate_arg_keys=True)\n</code></pre> <p>Build a tanjun.SlashCommand by decorating a function.</p> <p>This uses the function's name as the command's name and the first line of its docstring as the command's description.</p> <p>Note</p> <p>Under the standard implementation, <code>is_global</code> is used to determine whether the command should be bulk set by tanjun.Client.declare_global_commands or when <code>declare_global_commands</code> is True</p> <p>Warning</p> <p><code>default_member_permissions</code>, <code>dm_enabled</code> and <code>is_global</code> are ignored for commands within slash command groups.</p> <p>Note</p> <p>If you want your first response to be ephemeral while using <code>always_defer</code>, you must set <code>default_to_ephemeral</code> to <code>True</code>.</p> <p>Examples:</p> <pre><code>@doc_parse.as_slash_command()  # This command will be called \"ping\"\nasync def ping(ctx: tanjun.abc.SlashContext) -&gt; None:\n\"\"\"Get the bot's latency.\"\"\"\n    start_time = time.perf_counter()\n    await ctx.rest.fetch_my_user()\n    time_taken = (time.perf_counter() - start_time) * 1_000\n    await ctx.respond(f\"PONG\\n - REST: {time_taken:.0f}mss\")\n</code></pre> PARAMETER DESCRIPTION <code>always_defer</code> <p>Whether the contexts this command is executed with should always be deferred before being passed to the command's callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>default_member_permissions</code> <p>Member permissions necessary to utilize this command by default.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int, None]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>dm_enabled</code> <p>Whether this command is enabled in DMs with the bot.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_global</code> <p>Whether this command is a global command.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>name</code> <p>The command's name.</p> <p>This must fit discord's requirements and if left as None then the command callback's name is used.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>None</code> </p> <code>sort_options</code> <p>Whether this command should sort its set options based on whether they're required.</p> <p>If this is True then the options are re-sorted to meet the requirement from Discord that required command options be listed before optional ones.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.SlashCallbackSig], SlashCommand]</code> <p>The decorator callback used to make a tanjun.SlashCommand.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand tanjun.SlashCommand) and will manage loading the other command into a component when using tanjun.Component.load_from_scope.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name is over 32 characters long.</li> <li>If the command name has uppercase characters.</li> <li>If the description is over 100 characters long.</li> </ul>"},{"location":"reference/doc_parse/#tanchan.doc_parse.slash_command_group","title":"slash_command_group","text":"<pre><code>slash_command_group(name, description, /, *, default_member_permissions=None, default_to_ephemeral=None, dm_enabled=None, is_global=True)\n</code></pre> <p>Create a slash command group.</p> <p>Note</p> <p>Unlike message command groups, slash command groups cannot be callable functions themselves.</p> <p>Warning</p> <p><code>default_member_permissions</code>, <code>dm_enabled</code> and <code>is_global</code> are ignored for command groups within other slash command groups.</p> <p>Note</p> <p>Under the standard implementation, <code>is_global</code> is used to determine whether the command should be bulk set by tanjun.Client.declare_global_commands or when <code>declare_global_commands</code> is True</p> <p>Examples:</p> <p>Sub-commands can be added to the created slash command object through the following decorator based approach:</p> <pre><code>help_group = doc_parse.slash_command_group(\"help\", \"get help\")\n\n@tanjun.with_str_slash_option(\"command_name\", \"command name\")\n@help_group.as_sub_command\nasync def help(ctx: tanjun.abc.SlashContext, command_name: str) -&gt; None:\n\"\"\"Get help with a command.\"\"\"\n\n@help_group.as_sub_command\nasync def me(ctx: tanjun.abc.SlashContext) -&gt; None:\n\"\"\"Help me.\"\"\"\n\ncomponent = tanjun.Component().add_slash_command(help_group)\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>The name of the command group (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The description of the command group (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default_member_permissions</code> <p>Member permissions necessary to utilize this command by default.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int, None]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>dm_enabled</code> <p>Whether this command is enabled in DMs with the bot.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_global</code> <p>Whether this command is a global command.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>SlashCommandGroup</code> <p>The command group.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name doesn't fit Discord's requirements.</li> <li>If the command name has uppercase characters.</li> <li>If the description is over 100 characters long.</li> </ul>"},{"location":"reference/doc_parse/#tanchan.doc_parse.with_annotated_args","title":"with_annotated_args","text":"<pre><code>with_annotated_args(command=None, /, *, doc_style=None, follow_wrapped=False)\n</code></pre> <p>Docstring parsing implementation of tanjun.annotations.with_annotated_args.</p> <p>Examples:</p> <p>This will parse command option descriptions from the command's docstring.</p> <pre><code>@doc_parse.with_annotated_args\n@doc_parse.as_slash_command()\nasync def toggle_setting(ctx: tanjun.abc.Context, user: annotations.User, state: annotations.Bool = False) -&gt; None:\n\"\"\"Toggle this setting for a user.\n\n    Parameters\n    ----------\n    user\n        The user to toggle this setting for.\n    state\n        Whether this should be enabled.\n    \"\"\"\n\n@doc_parse.with_annotated_args\n@doc_parse.as_slash_command()\nasync def ban_user(ctx: tanjun.abc.Context, user: annotations.User) -&gt; None:\n\"\"\"Ban a user from this guild.\n\n    Args:\n        user:\n            The user to ban.\n    \"\"\"\n\n@doc_parse.with_annotated_args\n@doc_parse.as_slash_command()\nasync def unban_user(ctx: tanjun.abc.Context, user: annotations.User, reason: str = None) -&gt; None:\n\"\"\"Unban a user from this guild.\n\n    :param user: The user to unban.\n    :param reason: The reason for unbanning them.\n    \"\"\"\n</code></pre> <p>This also supports parsing option descriptions from the typed dict that's being used as the unpacked <code>**kwargs</code> type-hint.</p> <pre><code>class BulkMessagOptions(typing.TypedDict, total=False):\n\"\"\"Reused bulk message command options.\n\n    Parameters\n    ----------\n    count\n        The amount of messages to target.\n    regex\n        A regular expression to match against message contents.\n    \"\"\"\n\n    count: annotations.Int\n    regex: annotations.Str\n\n@doc_parse.with_annotated_args\n@doc_parse.as_slash_command()\nasync def delete_messages(\n    ctx: tanjun.abc.Context, reason: str = None, **kwargs: typing.Unpack[BulkMessagOptions]\n) -&gt; None:\n\"\"\"Toggle this setting for a user.\n\n    Parameters\n    ----------\n    reasom\n        Why you're bulk deleting these messages.\n    \"\"\"\n</code></pre> PARAMETER DESCRIPTION <code>command</code> <p>The message or slash command to set the arguments for.</p> <p> TYPE: <code>tanjun.SlashCommand | tanjun.MessageCommand</code> DEFAULT: <code>None</code> </p> <code>doc_style</code> <p>The docstyle to parse slash command option descriptions from.</p> <p>This may be either <code>\"google\"</code>, <code>\"numpy\"</code>, or <code>\"reST\"</code>. If left as None then this will try to auto-detect the style.</p> <p> TYPE: <code>typing.Optional[_DocStyleUnion]</code> DEFAULT: <code>None</code> </p> <code>follow_wrapped</code> <p>Whether this should also set the arguments on any other command objects this wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tanjun.SlashCommand | tanjun.MessageCommand</code> <p>The command object to enable using this as a decorator.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If <code>doc_style</code> is None and this failed to detect the docstring style.</p>"}]}